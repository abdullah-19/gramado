/*
 * Gramado Executive - The main file for the Executive module in the 
 * kernel base. 
 * (c) Copyright 2015-2016 Fred Nora.
 *
 * File: k\executive.c 
 * 
 * Classes:
 *     system.ram (K5)
 *
 * Obs: O executive lida com gerentes que manipulam rotinas independentes
 *      de dispositivos. Seu ambiente natural é a RAM. É o ambiente de maior
 *      liberdade, sem as restrições impostas pelos dispositivos externos.
 *      O ambiente do executive é ideal para oferecer variáveis e funções globais.
 * e públicas. O ideal é que os processos em user mode somente tenham acesso
 * ao que é oferecido por essa camada.
 *      Não é pertinente a inclusão de código assembly nessa camada.
 *
 * Descrição:
 *     Arquivo principal do módulo Executive do Kernel Base.
 *     MB - Módulos incluídos no Kernel Base.
 *     Contém drivers básicos em Kernel Mode, 
 *     compilados dentro do Kernel Base.
 *     Contém Managers e Servers e o SubSystem que recebe as 
 *     chamadas do usuário.
 *
 *   OBS: 
 *   *IMPORTANTE  
 *   Os módulos do executive são incluidos ao 'Kernel Base'
 *   na hora da compilação, pois são excenciais para o 
 *   funcionamento do Kernel.
 *
 *   Módulos em Kernel Mode também poderão ser ligados dinamicamente, 
 *   mas não podem ser sistemicamente importantes. Pois não é certo deixar
 *   o usuário incluir um módulo que possa travar o sistema.
 *
 * @todo:
 * Os serviços oferecidos por esse módulo aparecerão aqui 
 * começando por 'sys_'. Corrigindo, na verdade os serviços
 * devem começar por 'systemXXXXX'.
 *
 * executiveExecutive(); é o construtor
 *
 * Versão 1.0, 2015, 2016.
 */
 
 
#include <kernel.h>
//#include "eidata.h"  //Executive Internal Data.

//unsigned char  EcecutiveName[] = "EXECUTIVE LAYER";


/*
 *****************************************************************
 * executive_gramado_core_init_execve:
 *     Executa um programa no processo INIT 
 * dentro do ambiente Gramado Core. 
 * #obs: Isso funcionou.
 */
int executive_gramado_core_init_execve( const char *filename, 
                                        const char *argv[], 
                                        const char *envp[] )
{
	struct thread_d *Thread;
    
	//fail.
	int Status = 1;
	
	//fail.
	//if( (const char *) filename == NULL ){
	//	return 1;
	//}
	
	//
	// Testando carregar um programa para 
	// rodar no processo INIT, usando a thread 
	// primária do processo !
	//
	
	printf("\nexecutive_gramado_core_init_execve: testing ...\n");
	printf("fileneme={%s}\n",filename);
	printf("arg={%x}\n",argv[0]);
	printf("env={%x}\n",envp[0]);
	
	//
	// Pegar o ponteiro da thread primária do processo 
	// INIT.
	//
	
	Thread = (struct thread_d *) threadList[0];
	if( (void*) Thread == NULL )
	{
		goto fail;
	}else{
		
		if( Thread->used != 1 || Thread->magic != 1234 ){
			goto fail;
		}
		
		// Significa que o contexto nunca foi salvo ...
		// isso é importante, pois o spawn não funciona em thread 
		// com o contexto salvo.
		Thread->saved = 0; 
		
	    //Context.
	    //@todo: Isso deve ser uma estrutura de contexto.
	    Thread->ss  = 0x23;                          //RING 3.
	    Thread->esp = (unsigned long) 0x0044FFF0;    //idleStack; (*** RING 3)
	    Thread->eflags = 0x3200;  //0x3202, pois o bit 1 é reservado e está sempre ligado.
	    Thread->cs = 0x1B;                                
	    Thread->eip = (unsigned long) 0x00401000;   //entry point  	                                               
	    Thread->ds = 0x23; 
	    Thread->es = 0x23; 
	    Thread->fs = 0x23; 
	    Thread->gs = 0x23; 
	    Thread->eax = 0;
	    Thread->ebx = 0;
	    Thread->ecx = 0;
	    Thread->edx = 0;
	    Thread->esi = 0;
	    Thread->edi = 0;
	    Thread->ebp = 0;
		
		
		Thread->Next = NULL;
		
		//
		// Load file.
		//
 		
		
		//
		// #bugbug
		// #importante Precisamos do ponteiro válido para filename.
		// Não podemos auterá-lo e depois usá-lo.
		//
		
		//fs/read.c
	    // "FILE    BIN"
        Status = (int) fsLoadFile( (unsigned char *) filename, 
		                           (unsigned long) 0x00400000 );

        //fail
		if( Status == 1 )
		{
			// @todo:
			// Configurar estrutura.
			goto fail;
		};
		
		// Se deu certo.
		if( Status == 0 )
		{
		    queue_insert_data(queue, (unsigned long) Thread, QUEUE_INITIALIZED);
            SelectForExecution(Thread);    // * MOVEMENT 1 ( Initialized ---> Standby ).
            goto done; 
        };	
         
        //fail		 
	};
	
	//fail
	
fail:
    printf("fail ");
done:
    printf("done\n");	
	refresh_screen();
	return (int) Status;	
};


/*
void executiveMain();
void executiveMain(){
	return;
};
*/

/*
 * executive_config_exported_functions:
 *
 *     Configura a tabela do Kernel de funções exportadas
 *	   e a tabela de ponteiros para tabelas dos outros programas em Kernel Mode.
 *
 */
/*
int executive_config_exported_functions(); 
int executive_config_exported_functions()
{
	
    ring0_exported = (void*) malloc(sizeof(struct ring0_exported_d));
	
	if( (void*) ring0_exported == NULL )
	{
	    return (int) 1;
	}
	else
	{
	    //ring0_exported->bm_exported  = ( ponteiro para a tabela de funções exportadas pelo boot manager)
		//ring0_exported->bl_exported  = ( ponteiro para a tabela de funções exportadas pelo boot loader)
		//ring0_exported->bk_exported  = ( ponteiro para a tabela de funções exportadas pelo kernel)
		
		
		//@todo: Criar a tabela do kernel e salvar o ponteiro nessa estrutura ai.
		//       Pegar os ponteiros de bootmanager e bootloader e colocar ai.
		
	};
	
	
	// @todo: Nothing more?
	
done:
    return (int) 0;
};

*/

/*
 * sys_showkernelinfo:
 *     Show kernel info.
 */
void sys_showkernelinfo()
{
	KiInformation();
	return;
};


/*
 * init_executive:
 *     Initialize the kernel executive.
 *     Archtecture (independent) inicialization. 
 */
int init_executive()
{
    int Status = 0;
	
	printf("EXECUTIVE:\n");
	
	//  PCI - Pega informações da PCI.
	init_pci();
	
	// CLOCK - Pega informações de Hora e Data.
    init_clock();
	
	//configura a tabela do kernel de funções exportadas
	//e tabela de ponteiros para tabelas dos outros programas em kernel mode.
    //Status = (int) executive_config_exported_functions();

	//Continua ...
	
Done:
    
	//@todo: Checar a validade de 'Initialization' ??

    Initialization.executive = 1;	
	printf("Done!\n");	
	return (int) Status;
};


/*
int executiveInit()
{};
*/

//
// End.
//

